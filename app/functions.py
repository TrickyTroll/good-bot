# This file contains functions used by other scripts
import shutil
from pathlib import Path
import shlex
import time
import stat
import sys
import os
import subprocess

# ----------------------------------------------------------------------- #
#                    Finding the instructions
# ----------------------------------------------------------------------- #

def instruction_finder(read_path, filename):
    '''
    read_path: The path towards the video script that you wrote.
    
    filename: The full name of the script.

    Returns: A list of functions to be executed.
    
    Function's structure:
    {command: , media_format: , file_name: }
    '''
    todo = []
    # Changing directory to the one that contains the script. This 
    # should be the volume created with `docker run -v`.
    os.chdir(read_path)
    
    with open(read_path / filename, "r") as f:
        # Ignoring empty lines.
        datafile = [line for line in f.readlines() if line.strip()]
        index = 0
        for line in datafile:
            # The '(instructions:' part allows the program to skip headers.
            if '---' in line and '(instructions:' in datafile[index+1]:
                to_add = {
                        "command": datafile[index+2].rstrip().lstrip(),
                        "media_format": datafile[index+3].rstrip().lstrip(),
                        "file_name": datafile[index+4].rstrip().lstrip()
                        }
                todo.append(to_add)

            index += 1

    return todo

# ----------------------------------------------------------------------- #
#                        Editing the script 
# ----------------------------------------------------------------------- #
def new_script(instructions_list, read_path, write_path, filename):
    '''
    Takes the instructions_list from instruction_finder(). Uses the 
    instructions to generate a new script file, formatted to work using 
    Video Puppet.

    instructions_list: A list of instructions. Instructions are 
    dictionnaries created with the instruction_finder() function.
    
    read_path: The path to the script to read.
    
    write_path: The path to where the new script will be written.
    
    Creates: A markdown file that uses Video Puppet's syntax.

    Returns: The path towards the new script.
    '''
    # Changing directories to the one that contains the script.
    os.chdir(read_path)
    
    # Opening the file and storing the lines in a variable.
    with open(filename, 'r') as f:
        lines = f.readlines()
    # Changing directories to where script.md should be written.    
    os.chdir(write_path)
        
    with open('script.md', 'w') as f:
        index = 0
        title_index = 0

        while index < len(lines):
            
            # current_line_edited could be replaced by changing the 
            # next 'if' statement by if '---' in current_line.
            current_line_edited = lines[index].rstrip().lstrip()
            current_line = lines[index]

            if current_line_edited != "---":
                f.write(current_line)
                index += 1
            
            elif current_line_edited == "---":
                # This statement skips the header.
                if index == 0:
                    f.write(current_line)
                    index += 1
                else: # This means it's not the header.
                    current_title = instructions_list[title_index]["file_name"]
                    media_format = instructions_list[title_index]["media_format"]
                    f.write(current_line)
                    f.write("![freeze](%s.%s)\n"%(current_title, media_format))
                    index += 6
                    title_index += 1 

    return write_path / 'script.md'

# ----------------------------------------------------------------------- #
#                       Bash scripts creation
# ----------------------------------------------------------------------- #

def script_maker(instructions_list, path_to_create, path_to_demo_magic):
    '''
    instructions_list: List of instructions that is generated by 
    instruction_finder().
    
    path_to_create: Path to where the new folder containing the shell 
    scripts should be created.
    
    path_to_demo_magic: Path to the shell script file 'demo-magic.sh'.
    
    Creates: A bash script that uses demo-magic for every instruction in the
    list.
    
    Returns: The path to the folder containing the shell scripts.
    '''
    # Making a new directory for the scripts.

    parent = path_to_create
    newpath = parent / 'shell_scripts'
    
    if not os.path.exists(newpath):
        os.makedirs(newpath)

    # Changing to the new working directory.

    os.chdir(newpath)

    # Creating the scripts. See demo-magic on github.
    
    for i in instructions_list:
        identification = '%s.sh'%(i['file_name'])
        with open (identification, 'w') as shscr:
            shscr.write('''\
#!/usr/bin/env bash

# including demo-magic

. %s/demo-magic.sh

# speed (defined by the user)

TYPE_SPEED=%s
                    
# This should also be defined by the user...maybe later.

DEMO_PROMPT="${GREEN}âžœ ${CYAN}\W "

# Clearing the prompt

clear

# The commands go here

pe "%s"

# The end (shows a prompt at the end)

p ""
'''%(path_to_demo_magic, 10, i['command']))#Commands should be a list at some point
            
            # Making sure that the files are executable

        os.chmod(identification, stat.S_IRWXU)



    return newpath

# ----------------------------------------------------------------------- #
#                             Recording
# ----------------------------------------------------------------------- #


def start_rec(to_record, to_save, filename):
    '''
    Records to_record using ttyrec.
    
    to_record: Shoud be a path to a shell script created by script_maker.
    
    to_save: Path to where the recording should be saved.
    
    filename: The name of the file that will be created.
    
    creates: A ttyrec named after filename.
    
    Returns: 'Sould be recording...'
    '''
    # Defines the title of the video to the shell script's name
    # and the path to the new directory.
    
    title = to_save / str(filename).replace('.sh', '')
    print(title)

    # Starting ttyrec

    subprocess.run([
        'ttyrec',
        '-e',
        to_record,
        title
        ])
        
    return 'Should be recording...'
    


# ----------------------------------------------------------------------- #
#                         Instrucion executer
# ----------------------------------------------------------------------- #

def instruction_executer(working_path, path_to_scripts, path_to_save):
    '''
    Change directories to the working path. This makes sure that the 
    environment is clean for new recordings.
    
    Loops through every scripts inside to the folder provided by
    path_to_scripts. Runs the function start_rec for each script.

    The path is absolute.

    Returns: The path towards the new recordings.
    '''

    # Creating the new directory    
    newpath = path_to_save / 'recordings'
        
    if not os.path.exists(newpath):
        os.makedirs(newpath)
    
    # Executing start_rec for each.
    os.chdir(working_path)

    for filename in os.listdir(path_to_scripts):

        start_rec(path_to_scripts / filename, newpath, filename)

    return newpath


# ----------------------------------------------------------------------- #
#                         Asciicast converting
# ----------------------------------------------------------------------- #

def ttyrec_2gif(path_to_ttyrec, path_to_save):
    '''
    path_to_ttyrec: the path of the folder where the ttyrecs
    are saved.
    
    path_to_save: the path of the folder where the gifs are going to
    be saved.

    Converts the ttyrecs in path_to_ttyrec
    into gifs, and saves them inside of path_to_save.

    Returns 'Done!'
    '''
    # Iters over each file in path_to_ttyrec.
    for filename in os.listdir(path_to_ttyrec):

        subprocess.run([
           '/root/go/bin/ttyrec2gif', # This is where ttyrec2gif is located.
           '-in',
           path_to_ttyrec / str(filename),
           '-out',
           path_to_save / (str(filename) + '.gif')
            ])

    return 'Done!'

# ----------------------------------------------------------------------- #
#                               Conversion
# ----------------------------------------------------------------------- #


def ttyrec_transfer(path_to_recordings, product_path):
    '''
    path_to_recordings: Path towards the ttyrecs recordings.
    
    product_path: Path towards where the end product will be created.
    The end product is a folder that contains the gifs and the new script.
    
    This function Creates a new directory for the end product. 
    It then converts ttyrecs to gifs and saves the gifs in the 
    your_video directory using ttyrec_2gif.
    
    Returns: 'Done!'
    '''
    # Making a new directory inside of the docker volume.
    # This means the directory will also be on the host.
    current = product_path
    newpath = current / 'your_video'
    
    if not os.path.exists(newpath):
        os.makedirs(newpath)

    ttyrec_2gif(path_to_recordings, newpath)
        
    return 'Done'

def script_transfer(new_script_path, product_path):
    '''
    Transfers the script created to the your_video folder.
    
    new_script_path: Path to where the new script has been saved. This 
    should be returned by the new_script function.
    
    product_path: Path towards the volume that is mounted inside the 
    container. This means the script will also be available on the 
    host computer.
    '''
    
    subprocess.run([
        'cp',
        new_script_path,
        product_path / 'your_video'
        ])
    return 'Done!'

def cleanup():
    '''
    This functions cleans up the directory so that it can be used for another
    video!
    '''
    # Not sure if this is still useful since everything happens inside the
    # container.
    return None
